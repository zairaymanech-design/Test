import { Component, OnInit } from '@angular/core';
import { ChartConfiguration, ChartType } from 'chart.js';

type Row = [number, string, string, number]; // [ID, label, type, value]

@Component({
  selector: 'app-unique-pie',
  template: `
    <div class="chart-wrapper">
      <canvas baseChart
        [data]="chartData"
        [type]="chartType"
        [options]="chartOptions">
      </canvas>
    </div>
  `,
  styles: [`
    .chart-wrapper { width: 600px; margin: 2rem auto; }
  `]
})
export class UniquePieComponent implements OnInit {
  chartType: ChartType = 'pie';
  chartData!: ChartConfiguration<'pie'>['data'];

  chartOptions: ChartConfiguration<'pie'>['options'] = {
    responsive: true,
    plugins: {
      legend: { position: 'bottom' },
      tooltip: {
        callbacks: {
          label: (ctx) => `${ctx.label}: ${ctx.parsed}`
        }
      }
    }
  };

  // ðŸ”¹ Your array data
  dataArray: Row[] = [
    [1, 'Apples', 'Fruit', 30],
    [1, 'Carrots', 'Vegetable', 20],
    [2, 'Bananas', 'Fruit', 15],
    [2, 'Broccoli', 'Vegetable', 25],
    [3, 'Steak', 'Meat', 40],
    [3, 'Chicken', 'Meat', 35],
    // ... add up to 220+ rows
  ];

  ngOnInit(): void {
    this.chartData = this.transformData(this.dataArray);
  }

  private transformData(rows: Row[]): ChartConfiguration<'pie'>['data'] {
    // Merge duplicate IDs into single group slices (but keep individual type values separate)
    const grouped: Record<number, Row[]> = {};
    rows.forEach(row => {
      const [id] = row;
      if (!grouped[id]) grouped[id] = [];
      grouped[id].push(row);
    });

    const labels: string[] = [];
    const values: number[] = [];
    
    // Generate a color for each slice
    const totalSlices = rows.length;
    const colors = this.generateColors(totalSlices);

    let colorIndex = 0;

    Object.entries(grouped).forEach(([id, group]) => {
      group.forEach(([_, label, type, value]) => {
        labels.push(`ID ${id} - ${label} (${type})`);
        values.push(value);
        colorIndex++; // advance color index
      });
    });

    return {
      labels,
      datasets: [{
        data: values,
        backgroundColor: this.generateColors(values.length), // unique vivid colors
        borderColor: '#000',
        borderWidth: 1
      }]
    };
  }

  // Generates N unique vivid colors
  private generateColors(n: number): string[] {
    const colors: string[] = [];
    for (let i = 0; i < n; i++) {
      colors.push(this.randomColor());
    }
    return colors;
  }

  // Random vivid color (RGB) â€” never white/pale
  private randomColor(): string {
    const r = Math.floor(Math.random() * 156) + 50; // 50â€“205
    const g = Math.floor(Math.random() * 156) + 50;
    const b = Math.floor(Math.random() * 156) + 50;
    return `rgb(${r}, ${g}, ${b})`;
  }
}